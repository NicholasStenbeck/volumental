{"ast":null,"code":"var _jsxFileName = \"/Users/nicholasstenbeck/Documents/Job/repo.nosync/volumental/frontend_challenge/src/components/FeetScanPlaceholder/FeetScanPlaceholder.tsx\",\n  _s = $RefreshSig$();\nimport { css } from \"@emotion/css\";\nimport * as React from \"react\";\nimport { SceneManager } from \"./scene_manager\";\nimport { rootElement } from \"rootElement\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst styles = {\n  canvasContainer: css`\n    height: 100vh;\n    width: 100vw;\n    position: absolute;\n  `,\n  canvas: css`\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n    overflow: visible;\n  `,\n  slider: css`\n    position: absolute;\n    cursor: ew-resize;\n    width: 40px;\n    height: 40px;\n    background-color: #1cb5d1;\n    opacity: 0.7;\n    border-radius: 50%;\n    top: calc(50% - 20px);\n    left: 50%;\n  `\n};\nexport const FeetScanPlaceholder = props => {\n  _s();\n  const containerRef = React.useRef(null);\n  const sliderRef = React.useRef(null);\n  React.useEffect(() => {\n    /**\n     * Use guard clause instead of nesting the rest of the code in an if statement.\n     * This improves readability and reduces nesting.\n     */\n    if (!containerRef.current || !sliderRef.current) {\n      return;\n    }\n\n    // For cleanup of event listeners\n    const currentSlider = sliderRef.current;\n    const container = containerRef.current;\n    new SceneManager(containerRef.current, currentSlider, props.cameraPosition, props.sceneLBackground, props.sceneRBackground);\n\n    /**\n     * Thanks to the guard clause above, we can assume that the saved\n     * sliderRef.current is not null, so we can remove the null check\n     * for better readability.\n     */\n    const onMouseMove = event => {\n      var _ref;\n      const sliderPos = Math.max(0, Math.min(rootElement.offsetWidth, event.pageX));\n      /**\n       * Expressed the slider position in percent instead, so that it can stay in\n       * roughly the same position when the window is resized. This also removes\n       * the need to use a resize listener.\n       */\n      currentSlider.style.left = `${((_ref = (sliderPos - currentSlider.offsetWidth / 2) / container.offsetWidth) !== null && _ref !== void 0 ? _ref : 1) * 100}%`;\n    };\n    const onMouseDown = _ => {\n      rootElement.addEventListener(\"mousemove\", onMouseMove);\n      rootElement.addEventListener(\"mouseup\", onMouseUp);\n    };\n    const onMouseUp = _ => {\n      rootElement.removeEventListener(\"mousemove\", onMouseMove);\n      rootElement.removeEventListener(\"mouseup\", onMouseUp);\n    };\n    const onTouchStart = event => {\n      event.preventDefault();\n      rootElement.addEventListener(\"touchmove\", onTouchMove);\n      rootElement.addEventListener(\"touchend\", onTouchEnd);\n    };\n\n    /**\n     * Add support for mobile devices.\n     * This is a very basic implementation, but it should work\n     * for moving the slider.\n     */\n    const onTouchMove = event => {\n      var _ref2;\n      event.preventDefault();\n      const sliderPos = Math.max(0, Math.min(rootElement.offsetWidth, event.touches[0].pageX));\n      /**\n       * Expressed the slider position in percent instead, so that it can stay in\n       * roughly the same position when the window is resized. This also removes\n       * the need to use a resize listener.\n       */\n      currentSlider.style.left = `${((_ref2 = (sliderPos - currentSlider.offsetWidth / 2) / container.offsetWidth) !== null && _ref2 !== void 0 ? _ref2 : 1) * 100}%`;\n    };\n    const onTouchEnd = event => {\n      event.preventDefault();\n      rootElement.removeEventListener(\"touchmove\", onTouchMove);\n      rootElement.removeEventListener(\"touchend\", onTouchEnd);\n    };\n    currentSlider.addEventListener(\"mousedown\", onMouseDown);\n    currentSlider.addEventListener(\"touchstart\", onTouchStart);\n\n    /**\n     * Including mousemove and mouseup just in case the component unmounts\n     * while the mouse is down. This would probably not happen, but\n     * it's better to be safe than sorry.\n     */\n    return () => {\n      currentSlider.removeEventListener(\"mousedown\", onMouseDown);\n      rootElement.removeEventListener(\"mousemove\", onMouseMove);\n      rootElement.removeEventListener(\"mouseup\", onMouseUp);\n    };\n  }, [props]);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.canvasContainer,\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: styles.canvas,\n        id: \"canvas\",\n        ref: containerRef\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 154,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 153,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.slider,\n      id: \"slider\",\n      ref: sliderRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 156,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n};\n_s(FeetScanPlaceholder, \"8PiHHqFBp2916apaNCmDK6kAiEE=\");\n_c = FeetScanPlaceholder;\nvar _c;\n$RefreshReg$(_c, \"FeetScanPlaceholder\");","map":{"version":3,"names":["css","React","SceneManager","rootElement","styles","canvasContainer","canvas","slider","FeetScanPlaceholder","props","containerRef","useRef","sliderRef","useEffect","current","currentSlider","container","cameraPosition","sceneLBackground","sceneRBackground","onMouseMove","event","sliderPos","Math","max","min","offsetWidth","pageX","style","left","onMouseDown","_","addEventListener","onMouseUp","removeEventListener","onTouchStart","preventDefault","onTouchMove","onTouchEnd","touches"],"sources":["/Users/nicholasstenbeck/Documents/Job/repo.nosync/volumental/frontend_challenge/src/components/FeetScanPlaceholder/FeetScanPlaceholder.tsx"],"sourcesContent":["import { css } from \"@emotion/css\";\nimport * as React from \"react\";\n\nimport { SceneManager } from \"./scene_manager\";\nimport { rootElement } from \"rootElement\";\n\nconst styles = {\n  canvasContainer: css`\n    height: 100vh;\n    width: 100vw;\n    position: absolute;\n  `,\n  canvas: css`\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n    overflow: visible;\n  `,\n  slider: css`\n    position: absolute;\n    cursor: ew-resize;\n    width: 40px;\n    height: 40px;\n    background-color: #1cb5d1;\n    opacity: 0.7;\n    border-radius: 50%;\n    top: calc(50% - 20px);\n    left: 50%;\n  `,\n};\n\ninterface FeetScanPlaceholderProps {\n  sceneLBackground: THREE.Color;\n  sceneRBackground: THREE.Color;\n  cameraPosition: {\n    x: number;\n    y: number;\n    z: number;\n  };\n}\n\nexport const FeetScanPlaceholder: React.FC<FeetScanPlaceholderProps> = (\n  props\n) => {\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const sliderRef = React.useRef<HTMLDivElement>(null);\n\n  React.useEffect(() => {\n    /**\n     * Use guard clause instead of nesting the rest of the code in an if statement.\n     * This improves readability and reduces nesting.\n     */\n    if (!containerRef.current || !sliderRef.current) {\n      return;\n    }\n\n    // For cleanup of event listeners\n    const currentSlider = sliderRef.current;\n    const container = containerRef.current;\n\n    new SceneManager(\n      containerRef.current,\n      currentSlider,\n      props.cameraPosition,\n      props.sceneLBackground,\n      props.sceneRBackground\n    );\n\n    /**\n     * Thanks to the guard clause above, we can assume that the saved\n     * sliderRef.current is not null, so we can remove the null check\n     * for better readability.\n     */\n    const onMouseMove = (event: MouseEvent) => {\n      const sliderPos = Math.max(\n        0,\n        Math.min(rootElement.offsetWidth, event.pageX)\n      );\n      /**\n       * Expressed the slider position in percent instead, so that it can stay in\n       * roughly the same position when the window is resized. This also removes\n       * the need to use a resize listener.\n       */\n      currentSlider.style.left = `${\n        ((sliderPos - currentSlider.offsetWidth / 2) / container.offsetWidth ??\n          1) * 100\n      }%`;\n    };\n\n    const onMouseDown = (_: MouseEvent) => {\n      rootElement.addEventListener(\"mousemove\", onMouseMove);\n      rootElement.addEventListener(\"mouseup\", onMouseUp);\n    };\n\n    const onMouseUp = (_: MouseEvent) => {\n      rootElement.removeEventListener(\"mousemove\", onMouseMove);\n      rootElement.removeEventListener(\"mouseup\", onMouseUp);\n    };\n\n    const onTouchStart = (event: TouchEvent) => {\n      event.preventDefault();\n      rootElement.addEventListener(\"touchmove\", onTouchMove);\n      rootElement.addEventListener(\"touchend\", onTouchEnd);\n    };\n\n    /**\n     * Add support for mobile devices.\n     * This is a very basic implementation, but it should work\n     * for moving the slider.\n     */\n    const onTouchMove = (event: TouchEvent) => {\n      event.preventDefault();\n      const sliderPos = Math.max(\n        0,\n        Math.min(rootElement.offsetWidth, event.touches[0].pageX)\n      );\n      /**\n       * Expressed the slider position in percent instead, so that it can stay in\n       * roughly the same position when the window is resized. This also removes\n       * the need to use a resize listener.\n       */\n      currentSlider.style.left = `${\n        ((sliderPos - currentSlider.offsetWidth / 2) / container.offsetWidth ??\n          1) * 100\n      }%`;\n    };\n\n    const onTouchEnd = (event: TouchEvent) => {\n      event.preventDefault();\n      rootElement.removeEventListener(\"touchmove\", onTouchMove);\n      rootElement.removeEventListener(\"touchend\", onTouchEnd);\n    };\n\n    currentSlider.addEventListener(\"mousedown\", onMouseDown);\n    currentSlider.addEventListener(\"touchstart\", onTouchStart);\n\n    /**\n     * Including mousemove and mouseup just in case the component unmounts\n     * while the mouse is down. This would probably not happen, but\n     * it's better to be safe than sorry.\n     */\n    return () => {\n      currentSlider.removeEventListener(\"mousedown\", onMouseDown);\n      rootElement.removeEventListener(\"mousemove\", onMouseMove);\n      rootElement.removeEventListener(\"mouseup\", onMouseUp);\n    };\n  }, [props]);\n\n  return (\n    <>\n      <div className={styles.canvasContainer}>\n        <div className={styles.canvas} id=\"canvas\" ref={containerRef} />\n      </div>\n      <div className={styles.slider} id=\"slider\" ref={sliderRef} />\n    </>\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}